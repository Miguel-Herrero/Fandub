#!/usr/bin/env python3
"""
Low Frequency Noise Remover

Removes low frequency noise (air conditioning, microphone bumps, rumble)
using a high-pass filter optimized for dialogue preprocessing before stem splitting.

Uses 80 Hz cutoff with 2 poles - ideal for preserving dialogue while removing noise.
This is the third step in audio preprocessing for dubbing workflows.
"""

import sys
import argparse
import subprocess
from pathlib import Path
import logging
import json

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


def check_ffmpeg():
    """Check if FFmpeg is available and supports highpass filter."""
    try:
        # Check FFmpeg version
        result = subprocess.run(['ffmpeg', '-version'], 
                              capture_output=True, text=True, timeout=10)
        if result.returncode != 0:
            return False
            
        # Check if highpass filter is available
        result = subprocess.run(['ffmpeg', '-filters'], 
                              capture_output=True, text=True, timeout=10)
        return 'highpass' in result.stdout
        
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return False


def get_audio_info(input_file):
    """Get basic audio information using ffprobe."""
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-print_format', 'json',
            '-show_streams', '-select_streams', 'a:0', str(input_file)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        
        if result.returncode != 0:
            return None
            
        data = json.loads(result.stdout)
        
        if not data.get('streams'):
            return None
            
        stream = data['streams'][0]
        return {
            'codec': stream.get('codec_name', 'unknown'),
            'sample_rate': int(stream.get('sample_rate', 0)),
            'channels': int(stream.get('channels', 0)),
            'duration': float(stream.get('duration', 0)),
            'bit_rate': int(stream.get('bit_rate', 0)) if stream.get('bit_rate') else None
        }
    except Exception as e:
        logger.error(f"Error getting audio info: {e}")
        return None


def generate_output_filename(input_file, output_dir=None, project_name=None,
                           language=None, audio_type=None, version=None):
    """
    Generate a professional filename following dubbing conventions.
    
    Args:
        input_file: Path to input file
        output_dir: Output directory (default: same as input)
        project_name: Project name (default: extracted from input)
        language: Language code (default: extracted or 'UNK')
        audio_type: Audio type (default: 'MIX')
        version: Version number (default: 'v01')
    
    Returns:
        Path object with generated filename
    """
    input_path = Path(input_file)
    
    # Extract project name from filename if not provided
    if not project_name:
        # Remove common suffixes and clean up
        name = input_path.stem
        # Remove common patterns including previous processing steps
        for pattern in ['_audio', '_sound', '_track', '_final', '_master', '_wav', '_normalized', '_norm', '_filtered', '_hp']:
            name = name.replace(pattern, '')
        project_name = name.replace(' ', '').replace('-', '_')
    
    # Set defaults
    language = language or 'UNK'
    audio_type = audio_type or 'MIX'
    version = version or 'v01'
    
    # Generate filename: PROJECT_LANG_TYPE_filtered_VERSION.wav
    filename = f"{project_name}_{language}_{audio_type}_filtered_{version}.wav"
    
    # Determine output directory
    if output_dir:
        output_path = Path(output_dir)
    else:
        output_path = input_path.parent
    
    return output_path / filename


def remove_low_frequency_noise(input_file, output_file, overwrite=False, auto_name=False,
                              project_name=None, language=None, audio_type=None, version=None,
                              dry_run=False):
    """
    Remove low frequency noise using high-pass filter.
    
    Uses 80 Hz cutoff with 2 poles - optimized for dialogue preprocessing.
    
    Args:
        input_file: Path to input audio file
        output_file: Path to output filtered file (ignored if auto_name=True)
        overwrite: Whether to overwrite existing output file
        auto_name: Generate professional filename automatically
        project_name: Project name for auto naming
        language: Language code for auto naming
        audio_type: Audio type for auto naming
        version: Version for auto naming
        dry_run: Test processing without creating output file
    
    Returns:
        True if successful, False otherwise
    """
    input_path = Path(input_file)
    
    # Generate output filename if auto_name is enabled
    if auto_name:
        # If output_file is a directory, use it; otherwise use its parent
        output_dir = Path(output_file)
        if not output_dir.is_dir() and output_file.endswith('/'):
            # Create directory if it ends with /
            output_dir.mkdir(parents=True, exist_ok=True)
        elif not output_dir.is_dir():
            output_dir = output_dir.parent
        
        output_path = generate_output_filename(
            input_file,
            output_dir=output_dir,
            project_name=project_name,
            language=language,
            audio_type=audio_type,
            version=version
        )
        logger.info(f"Auto-generated filename: {output_path.name}")
    else:
        output_path = Path(output_file)
    
    # Check input file exists
    if not input_path.exists():
        logger.error(f"Input file not found: {input_path}")
        return False
    
    # Check if output exists and overwrite flag (skip for dry run)
    if not dry_run and output_path.exists() and not overwrite:
        logger.error(f"Output file exists (use --overwrite to replace): {output_path}")
        return False
    
    # Get input audio info
    logger.info(f"Analyzing input file: {input_path.name}")
    audio_info = get_audio_info(input_path)
    
    if not audio_info:
        logger.error("Could not analyze input audio file")
        return False
    
    logger.info(f"Input: {audio_info['codec']} | "
               f"{audio_info['sample_rate']}Hz | "
               f"{audio_info['channels']} channels | "
               f"{audio_info['duration']:.1f}s")
    
    # Build FFmpeg command for high-pass filtering
    cmd = ['ffmpeg']
    
    # Input file
    cmd.extend(['-i', str(input_path)])
    
    # Apply high-pass filter: 80 Hz cutoff, 2 poles (optimized for dialogue)
    cmd.extend(['-af', 'highpass=f=80:poles=2'])
    
    # Overwrite output
    if overwrite and not dry_run:
        cmd.append('-y')
    
    # Output file (use null output for dry run)
    if dry_run:
        cmd.extend(['-f', 'null', '-'])
        logger.info("DRY RUN: Testing high-pass filter without creating output file")
    else:
        cmd.append(str(output_path))
    
    # Execute filtering
    logger.info("Applying high-pass filter (80 Hz, 2 poles) to remove low frequency noise...")
    logger.info("This removes air conditioning, microphone bumps, and rumble while preserving dialogue")
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
        
        if result.returncode != 0:
            logger.error(f"FFmpeg filtering failed: {result.stderr}")
            return False
        
        if dry_run:
            logger.info(f"✅ Dry run successful!")
            logger.info(f"High-pass filter would create: {output_path}")
            logger.info("No output file was created (dry run mode)")
        else:
            # Verify output file was created
            if not output_path.exists():
                logger.error("Output file was not created")
                return False
            
            # Get output file size
            size_mb = output_path.stat().st_size / (1024 * 1024)
            
            logger.info(f"✅ High-pass filtering successful!")
            logger.info(f"Output: {output_path}")
            logger.info(f"Size: {size_mb:.1f} MB")
        
        return True
        
    except subprocess.TimeoutExpired:
        logger.error("Filtering timed out (file too large or system too slow)")
        return False
    except Exception as e:
        logger.error(f"Filtering error: {e}")
        return False


def main():
    """Main CLI interface."""
    parser = argparse.ArgumentParser(
        description="Remove low frequency noise for dialogue preprocessing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Basic high-pass filtering (recommended for dialogue)
  ./remove_low_frequency_noise -i audio.wav -o filtered.wav

  # Professional naming (recommended)
  ./remove_low_frequency_noise -i audio.wav -o processed/ --auto-name --project SherlockHolmes --language EN

  # Test filtering without creating output file
  ./remove_low_frequency_noise -i audio.wav -o filtered.wav --dry-run

Filter Settings:
  - Cutoff: 80 Hz (removes noise, preserves dialogue)
  - Poles: 2 (smooth rolloff, minimal artifacts)
  
This removes air conditioning, microphone bumps, rumble, and electrical noise
while preserving all dialogue content for optimal stem splitting.
        """
    )
    
    # Required arguments
    parser.add_argument('-i', '--input', required=True,
                       help='Input audio file (preferably WAV)')
    parser.add_argument('-o', '--output', required=True,
                       help='Output filtered file or directory (for auto-naming)')
    
    # Optional arguments
    parser.add_argument('--overwrite', action='store_true',
                       help='Overwrite output file if it exists')
    parser.add_argument('--dry-run', action='store_true',
                       help='Test filtering without creating output file')
    
    # Professional naming options
    parser.add_argument('--auto-name', action='store_true',
                       help='Generate professional filename automatically')
    parser.add_argument('--project', type=str,
                       help='Project name for auto naming (e.g., SherlockHolmes)')
    parser.add_argument('--language', type=str,
                       help='Language code for auto naming (e.g., EN, ES, FR)')
    parser.add_argument('--type', type=str, choices=['MIX', 'VOX', 'MNE', 'MUS', 'SFX'],
                       help='Audio type for auto naming (default: MIX)')
    parser.add_argument('--version', type=str,
                       help='Version for auto naming (e.g., v01, v02)')
    
    # Other options
    parser.add_argument('--verbose', action='store_true',
                       help='Enable verbose logging')
    
    args = parser.parse_args()
    
    # Set logging level
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Check dependencies
    print("🔇 Low Frequency Noise Remover")
    print("=" * 40)
    
    if not check_ffmpeg():
        logger.error("FFmpeg not found or highpass filter not available.")
        logger.error("Please install a recent version of FFmpeg.")
        return 1
    
    # Perform filtering
    success = remove_low_frequency_noise(
        input_file=args.input,
        output_file=args.output,
        overwrite=args.overwrite,
        auto_name=args.auto_name,
        project_name=args.project,
        language=args.language,
        audio_type=args.type,
        version=args.version,
        dry_run=args.dry_run
    )
    
    if success:
        print("\n💡 Next steps:")
        print("• Low frequency noise has been removed")
        print("• Audio is now cleaner for normalization and stem splitting")
        print("• Consider normalization if not done yet")
        return 0
    else:
        logger.error("High-pass filtering failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
